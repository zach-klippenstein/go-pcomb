// Package pcomb provides parser combinators for parsing strings.
package pcomb

import (
	"fmt"
	"strings"
)

type ParseResult struct {
	// Token is the token generated by the Parser, or nil
	Token *Token

	// Err is nil if the Parser succeeded.
	Err error

	// NextInput is the input leftover after consuming Token.
	NextInput Input
}

type ParserFunc func(Input) ParseResult

type Parser interface {
	Parse(Input) ParseResult
	String() string
}

// NamedParser is a parser that has a static name, and points to a function that does the actual parsing.
type NamedParser struct {
	Name   string
	Parser ParserFunc
}

// Noop is a parser that just returns its input.
var Noop = NamedParser{"noop", func(i Input) ParseResult {
	return ParseResult{
		NextInput: i,
	}
}}

func (p NamedParser) Parse(i Input) ParseResult {
	return p.Parser(i)
}

func (p NamedParser) String() string {
	return p.Name
}

// String accepts a fixed string value.
func String(value string) Parser {
	return NamedParser{fmt.Sprintf("%q", value), func(i Input) ParseResult {
		if strings.HasPrefix(i.Value(), value) {
			return ParseResult{
				Token:     NewValueToken(value),
				NextInput: i.Advance(len(value)),
			}
		}

		return ParseResult{
			Err:       fmt.Errorf("input doesn't match ‘%s’ at %v", value, i),
			NextInput: i,
		}
	}}
}

// Ignore accepts the parser but discards the token (ParseResult.Token == nil).
func Ignore(parser Parser) Parser {
	return NamedParser{fmt.Sprintf("ignore(%s)", parser), func(input Input) ParseResult {
		result := parser.Parse(input)

		if result.Err != nil {
			return result
		}

		return ParseResult{
			NextInput: result.NextInput,
		}
	}}
}

// Sequence accepts all the parsers passed, in order, once.
func Sequence(parsers ...Parser) Parser {
	return NamedParser{fmt.Sprintf("(%s)", parsers), func(input Input) ParseResult {
		tokens := make([]*Token, len(parsers))

		for i := 0; i < len(parsers); i++ {
			result := parsers[i].Parse(input)

			if result.Err != nil {
				return result
			}

			tokens[i] = result.Token
			input = result.NextInput
		}

		return ParseResult{
			Token:     NewTokensToken(tokens...),
			NextInput: input,
		}
	}}
}

// FirstOf accepts the first parser to match the input.
func FirstOf(parsers ...Parser) Parser {
	return NamedParser{fmt.Sprintf("any(%s)", parsers), func(input Input) ParseResult {
		for _, parser := range parsers {
			result := parser.Parse(input)

			if result.Err == nil {
				return result
			}
		}

		return ParseResult{
			Err:       fmt.Errorf("input doesn't match any of %+v at %v", parsers, input),
			NextInput: input,
		}
	}}
}

// Repeat accepts a parser [min, max] consecutive times.
// If max is 0, it is unbounded.
func Repeat(parser Parser, min, max uint) Parser {
	name := "(%s){%d.."

	if max == 0 {
		name += "}"
		name = fmt.Sprintf(name, parser, min)
	} else {
		name += "%d}"
		name = fmt.Sprintf(name, parser, min, max)
	}

	return NamedParser{name, func(input Input) ParseResult {
		originalInput := input
		var i uint
		var result ParseResult
		tokens := make([]*Token, 0, min)

		for i = 0; i < max || max == 0; i++ {
			result = parser.Parse(input)

			if result.Err != nil {
				break
			}

			tokens = append(tokens, result.Token)
			input = result.NextInput
		}

		if i < min {
			return ParseResult{
				NextInput: originalInput,
				Err:       fmt.Errorf("input doesn't match at least %d instances of %s: %v", min, parser, originalInput),
			}
		}

		/*if max > 0 && i < max {
			return ParseResult{
				NextInput: originalInput,
				Err:       fmt.Errorf("input doesn't match up to %d instances of %s: %v", max, parser, originalInput),
			}
		}*/

		if len(tokens) == 0 {
			return ParseResult{
				NextInput: input,
				Token:     nil,
			}
		}

		return ParseResult{
			NextInput: input,
			Token:     NewTokensToken(tokens...),
		}
	}}
}

// Maybe is equivalent to Repeat(parser, 0, 1)
func Maybe(parser Parser) Parser {
	return Repeat(parser, 0, 1)
}
